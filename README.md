# Java言語で学ぶデザインパターン入門

## 01.Iterator  
対象に依存せずIterateできる。  
Iterateの順序などカスタムできる。

## 02.Adapter
既存Adapteeに一切手を加えずに流用できる。  
既存クラスの使用さえ分かれば作れるし、再テストせずに済む。

## 03.Template Method
親クラスで処理の枠組みを定め、サブクラスで実装する。

## 04.Factory Method
直接インスタンス生成せずFactoryのメソッドによってインスタンスを生成して返す。  
インスタンス生成にTemplate Methodを使う。

## 05.Singleton
特定クラスのインスタンスを1個に制限する。  
N個に制限するなど応用もある。

## 06.Prototype
インスタンスから別のインスタンスを作り出す。  
複雑なインスタンス生成工程を省く。

## 07.Builder
複雑なインスタンスを、メソッドを用いて組み上げる。  
Builderはサブクラスの組み立てに必要なメソッドを網羅する必要がある。

## 08.AbstractFactory
抽象的な工場と部品の組み合わせを定義して、具体的な実装を設計する。  
ConcreteFactoryの追加は簡単。何を実装すればいいか明らか。  
部品の追加は困難。関連する全ての向上を改修する必要がある。

## 09.Bridge
機能のクラス階層と実装のクラス階層を分離して橋渡しする。  

## 10.Strategy
アルゴリズムの切り替え。同じ問題を別の方法で解く。  
計算アルゴリズムや将棋のロジック切り替えなど。リソースや難易度などに応じる。

## 11.Composite
容器と中身を同一視し、再帰的な構造を作る。  
ディレクトリの中にサブディレクトリやファイルがあるようなパターン。

## 12.Decorator
中心となる機能に対して機能を付け加えてDecorateする。  
Decorateされる中身を変更することなく、機能（Decorate)を追加できるが、クラスが増える傾向。

## 13.Visitor
構造と処理を分離する。Directory内容を再帰的に訪問しながら処理する等。  
処理種類の追加が容易。構造の追加は困難。構造クラスだけvisitを追加する必要がある。

## 14.Chain of Responsibility
処理できない要求がきたら次の処理にたらい回しする。  
連鎖の順序や形態を変更可能。各処理を明確化・専門家できる。

## 15.Facade
複雑な処理をまとめて高レベルAPIとして窓口を提供する。  

## 16.Mediator
オブジェクト間の通信を一手に引き受け、状態管理などを統括する。  

## 17.Observer
観察対象の状態が変化すると処理が実行される。というより、通知とそれに応じた処理。  
状態変化に応じた処理を実装するときに有効。
